---
title: '2024.12.9-2024.12.15 学习内容'
date: 2024-12-9
permalink: /posts/2024/12/blog-post-2/
tags:
  - Arm
  - 向量指令集
  - C++
  - Asmjit
---

对代码中对指令进行解析的部分进行完善，主要是向量寄存器与指令类型。

## 1、InstType补充

### 1.1 向量寄存器Type

- 



### 1.2 访存模式回顾与系统支持访存模式

参考官方文档：[Loads and stores](https://developer.arm.com/documentation/102374/0102/Loads-and-stores---addressing)。

整体上主要有四种，目前我们的系统均支持，对应的类型为：

| 寻址方式                    | 操作数     | 计算模式 | 副作用        | 对应Type                                     |
| --------------------------- | ---------- | -------- | ------------- | -------------------------------------------- |
| Base register               | [GP]       | GP       |               | <font color=red>BaseROnlyMemType</font>      |
| Offset addressing modes     | [GP, IMM]  | GP+IMM   |               | <font color=red>BasePlusOffsetMemType</font> |
| Pre-index addressing modes  | [GP, IMM]! | GP+IMM   | GP = GP + IMM | <font color=red>PreIndexMemType</font>       |
| Post-index addressing modes | [GP], IMM  | GP       | GP = GP + IMM | <font color=red>PostIndexMemType</font>      |

### 1.3 指令语义

所有的指令语义参考: [**Arm A-profile A64 Instruction Set Architecture**文档](https://developer.arm.com/documentation/ddi0602/2024-09)

- LD1

关于该指令，参考官方文档：[LD1 (multiple structures)](https://developer.arm.com/documentation/ddi0602/2024-09/SIMD-FP-Instructions/LD1--multiple-structures---Load-multiple-single-element-structures-to-one--two--three--or-four-registers-?lang=en#iclass_post_index)

在该指令中，可以使用的vector类型包括：

| 寄存器 | 宽度 |
| ------ | ---- |
| 8B     | 64   |
| 16B    | 128  |
| 4H     | 64   |
| 8H     | 128  |
| 2S     | 64   |
| 4S     | 128  |
| 1D     | 64   |
| 2D     | 128  |

而对于访存，总共支持两种访存模式，分别为No-Offset（也就是BaseROnlyMemType）和Post-index。

在Post-index下，根据Q字段的不同，后索引只有两个取值：

| Q    | imm  |
| ---- | ---- |
| 0    | #8   |
| 1    | #16  |

因此，该指令需要补充的代码为（目前只补充**一个寄存器**的情况）：

```c++
// No-Offset部分
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "b"), BaseROnlyMemType::get())},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "b"), BaseROnlyMemType::get())},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "h"), BaseROnlyMemType::get())},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "h"), BaseROnlyMemType::get())},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "s"), BaseROnlyMemType::get())},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "s"), BaseROnlyMemType::get())},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "d"), BaseROnlyMemType::get())},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "d"), BaseROnlyMemType::get())},
// Post-index部分
// For the "One register, immediate offset" variant: is the post-index immediate offset, encoded in Q:
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "b"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "b"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "h"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "h"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "s"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "s"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(64, "d"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
{Inst::kIdLd1_v, InstType::get(REG_VEC_WID_RES(128, "d"), PostIndexMemType::get(generateImmediates(8, 16, 8)))},
```

- LD2

关于该指令，参考官方文档：[LD2 (multiple structures)](https://developer.arm.com/documentation/ddi0602/2024-09/SIMD-FP-Instructions/LD2--multiple-structures---Load-multiple-2-element-structures-to-two-registers-?lang=en)

在该指令中，可以使用的vector类型如下所示，注意不包括`1D`：

| 寄存器 | 宽度 |
| ------ | ---- |
| 8B     | 64   |
| 16B    | 128  |
| 4H     | 64   |
| 8H     | 128  |
| 2S     | 64   |
| 4S     | 128  |
| 2D     | 128  |

而对于访存，总共支持两种访存模式，分别为No-Offset（也就是BaseROnlyMemType）和Post-index。

在Post-index下，根据Q字段的不同，后索引只有两个取值：

| Q    | imm  |
| ---- | ---- |
| 0    | #16  |
| 1    | #32  |

因此，该指令需要补充的代码为：

```c++
// No-Offset部分
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(64, "b"), BaseROnlyMemType::get())},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "b"), BaseROnlyMemType::get())},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(64, "h"), BaseROnlyMemType::get())},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "h"), BaseROnlyMemType::get())},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(64, "s"), BaseROnlyMemType::get())},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "s"), BaseROnlyMemType::get())},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "d"), BaseROnlyMemType::get())},
// Post-index部分
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(64, "b"), PostIndexMemType::get(generateImmediates(16, 32, 16)))},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "b"), PostIndexMemType::get(generateImmediates(16, 32, 16)))},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(64, "h"), PostIndexMemType::get(generateImmediates(16, 32, 16)))},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "h"), PostIndexMemType::get(generateImmediates(16, 32, 16)))},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(64, "s"), PostIndexMemType::get(generateImmediates(16, 32, 16)))},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "s"), PostIndexMemType::get(generateImmediates(16, 32, 16)))},
{Inst::kIdLd2_v, InstType::get(REG_VEC_WID_RES(128, "d"), PostIndexMemType::get(generateImmediates(16, 32, 16)))},
```

- LD3
- LD4
- LD1R
- LD2R
- LD3R
- LD4R
- ST1
- ST2
- ST3
- ST4

### 1.4 附录：原有生成脚本的逻辑简介

SY姐之前使用python脚本，从Asmjit库中的...和...两个文件中提取。

逻辑是....

从第一个文件中....

然后在第二个文件中得到....

### 1.5 一些补充

其实在实际的指令中，`<T>`字段与`Q`字段<font color=red>强关联</font>，因此实际上不存在这么多的post-index。例如，对于`ld1`，当为`8B`时，`Q`一定为`0`，因此`post-index`一定是`8`，不会是16，而在我们补充的代码中全设置成一样的了。anyway，暂时先不改了，无所谓，不影响正确性。

## 2、寄存器格式解析

对于'{'的处理是较为简单的......
